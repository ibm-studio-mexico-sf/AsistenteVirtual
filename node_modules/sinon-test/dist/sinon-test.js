(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.sinonTest = factory());
}(this, (function () { 'use strict';

    /**
     * Internal utilities for sinon-test
     *
     * @author Christian Johansen (christian@cjohansen.no)
     * @license BSD
     *
     * Copyright (c) 2010-2013 Christian Johansen
     */

    /**
     * From version 3.1 Sinon uses factory methods for sandboxes and deprecates
     * sinon.sandbox. It - and its exports - will in time be removed/internalized, but
     * we can still support backwards compatibility easily.
     * See Sinon pull request #1515
    */
    function isOlderSinonVersion(sinonObj) {
        return typeof sinonObj.createSandbox === "undefined"
            && !!sinonObj.sandbox
            && typeof sinonObj.sandbox === "object"
            && typeof sinonObj.sandbox.create === "function";
    }

    var isPromise = function (object) {
        return typeof object === "object" && typeof object.then === "function";
    };

    var isSinon = function (obj) {
        return !!obj && typeof obj === "object"
            && (isOlderSinonVersion(obj) || typeof obj.createSandbox === "function");
    };

    var utils = {
    	isPromise: isPromise,
    	isSinon: isSinon
    };

    var defaultConfig = {
        injectIntoThis: true,
        injectInto: null,
        properties: ["spy", "stub", "mock", "clock", "server", "requests"],
        useFakeTimers: true,
        useFakeServer: true
    };

    var getConfig = function getConfig(custom) {
        var config = {};
        var prop;

        custom = custom || {};

        for (prop in defaultConfig) {
            if (defaultConfig.hasOwnProperty(prop)) {
                config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaultConfig[prop];
            }
        }

        return config;
    };

    var slice = Array.prototype.slice;

    function finish(sandbox, error, dontThrow) {
        if (error) {
            sandbox.restore();

            if (dontThrow) {
                return;
            }

            throw error;
        }

        sandbox.verifyAndRestore();
    }

    function handleFn(sandbox, result) {
        if (result && utils.isPromise(result)) {
            return result.then(
                function sinonHandlePromiseResolve(value) {
                    finish(sandbox);

                    return value;
                },
                function sinonHandlePromiseReject(error) {
                    finish(
                        sandbox,
                        error || new Error("Promise rejected with no/falsy error")
                    );
                }
            );
        }

        finish(sandbox);

        return result;
    }

    function handleAsyncFn(sandbox, result, isAsync) {
        if (result && utils.isPromise(result)) {
            if (!isAsync) { // # issue #75
                return handleFn(sandbox, result);
            }

            finish(sandbox, new Error(
                "Your test should take a callback *or* return a promise. "
                    + "It should not do both."
            ));
        }

        // the function had an arity of 1 or more, but it was not passed a callback
        if (!isAsync) {
            finish(sandbox);
        }

        return null;
    }

    function configure(sinon, config) {
        if (!utils.isSinon(sinon)) {
            throw new TypeError("expected sinon object");
        }

        var sandboxFactory = sinon.createSandbox || sinon.sandbox.create;

        function callSandboxedFn(context, args, fn, handler) {
            config = getConfig(config);
            config.injectInto = config.injectIntoThis && context || config.injectInto;
            var sandbox = sandboxFactory(config);
            var done = args.length && args[args.length - 1];
            var result;

            if (typeof done === "function") {
                args[args.length - 1] = function sinonDone(error) {
                    finish(sandbox, error, true);
                    done(error);
                };
            }

            try {
                result = fn.apply(context, args.concat(sandbox.args));
            } catch (e) {
                finish(sandbox, e);
            }

            return handler(sandbox, result, typeof done === "function");
        }

        return function test(callback) {
            var type = typeof callback;

            if (type !== "function") {
                throw new TypeError("sinon.test needs to wrap a test function, got " + type);
            }

            return callback.length
                ? function sinonAsyncSandboxedTest(_) { // eslint-disable-line no-unused-vars
                    return callSandboxedFn(this, slice.call(arguments), callback, handleAsyncFn);
                }
                : function sinonSandboxedTest() {
                    return callSandboxedFn(this, slice.call(arguments), callback, handleFn);
                }
            ;
        };
    }

    var configure_1 = configure;

    var test = {
    	configure: configure_1
    };

    function sinonTest(sinon, config) {
        return test.configure(sinon, config);
    }
    sinonTest.configureTest = function (sinon, config) {
        console.log("sinonTest.configureTest is deprecated and will be removed from the public API in a future version of sinon-test"); // eslint-disable-line
        return test.configure(sinon, config);
    };

    var lib = sinonTest;

    return lib;

})));
